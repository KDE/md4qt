/*!
    \page md4qt-README.md.html
    \l {https://opensource.org/licenses/MIT} {https://opensource.org/licenses/MIT}

    \c {md4qt} is a header-only C++ library for parsing Markdown.

    \c {md4qt} supports CommonMark 0.31.2 Spec, and some GitHub extensions, such as
    tables, footnotes, tasks lists, strikethroughs, LaTeX Maths injections, GitHub's auto-links.

    \c {md4qt} can be built with Qt6 or with ICU.

    This library parses Markdown into tree structure.


    \list
        \li \l {#Example//home/igor/Work/KDE/md4qt/README.md} {Example}
        \li \l {#Benchmark//home/igor/Work/KDE/md4qt/README.md} {Benchmark}
        \li \l {#Playground//home/igor/Work/KDE/md4qt/README.md} {Playground}
        \li \l {#Release-notes//home/igor/Work/KDE/md4qt/README.md} {Release notes}
        \li \l {#Known-issues//home/igor/Work/KDE/md4qt/README.md} {Known issues}
        \li \l {#QA//home/igor/Work/KDE/md4qt/README.md} {Q/A}
            \list
                \li \l {#Why-another-AST-Markdown-parser//home/igor/Work/KDE/md4qt/README.md} {Why another AST Markdown parser?}
                \li \l {#What-should-I-know-about-links-in-the-document//home/igor/Work/KDE/md4qt/README.md} {What should I know about links in the document?}
                \li \l {#What-is-the-second-argument-of-MDParserparse//home/igor/Work/KDE/md4qt/README.md} {What is the second argument of \c {MD::Parser::parse()}?}
                \li \l {#What-is-an-MDAnchor//home/igor/Work/KDE/md4qt/README.md} {What is an \c {MD::Anchor}?}
                \li \l {#Does-the-library-throw-exceptions//home/igor/Work/KDE/md4qt/README.md} {Does the library throw exceptions?}
                \li \l {#Why-MDParser-and-MDDocument-are-templates//home/igor/Work/KDE/md4qt/README.md} {Why \c {MD::Parser} and \c {MD::Document} are templates?}
                \li \l {#So-how-can-I-use-md4qt-with-Qt6-and-ICU//home/igor/Work/KDE/md4qt/README.md} {So, how can I use \c {md4qt} with \c {Qt6} and \c {ICU}?}
                \li \l {#ICU-is-slower-than-Qt6-Really//home/igor/Work/KDE/md4qt/README.md} {\c {ICU} is slower than \c {Qt6}? Really?}
                \li \l {#Why-is-parsing-wrong-on-Windows-with-stdifstream//home/igor/Work/KDE/md4qt/README.md} {Why is parsing wrong on Windows with \c {std::ifstream}?}
                \li \l {#How-can-I-convert-MDDocument-into-HTML//home/igor/Work/KDE/md4qt/README.md} {How can I convert \c {MD::Document} into \c {HTML}?}
                \li \l {#How-can-I-obtain-positions-of-blockselements-in-Markdown-file//home/igor/Work/KDE/md4qt/README.md} {How can I obtain positions of blocks/elements in \c {Markdown} file?}
                \li \l {#How-can-I-easily-traverse-through-the-MDDocument//home/igor/Work/KDE/md4qt/README.md} {How can I easily traverse through the \c {MD::Document}?}
                \li \l {#Why-dont-you-have-an-implementation-for-pure-STL-with-stdstring//home/igor/Work/KDE/md4qt/README.md} {Why don't you have an implementation for pure \c {STL} with \c {std::string}?}
                \li \l {#Is-it-possible-to-write-custom-text-plugin-for-this-parser//home/igor/Work/KDE/md4qt/README.md} {Is it possible to write custom text plugin for this parser?}
                    \list
                        \li \l {#What-is-a-ID-of-a-plugin//home/igor/Work/KDE/md4qt/README.md} {What is a \c {ID} of a plugin?}
                        \li \l {#What-is-a-MDTextPluginFuncTrait//home/igor/Work/KDE/md4qt/README.md} {What is a \c {MD::TextPluginFunc<Trait>}?}
                        \li \l {#What-is-processInLinks-flag-for//home/igor/Work/KDE/md4qt/README.md} {What is \c {processInLinks} flag for?}
                        \li \l {#What-for-is-a-userData-argument//home/igor/Work/KDE/md4qt/README.md} {What for is a \c {userData} argument?}
                        \li \l {#Could-you-show-an-example-of-a-plugin//home/igor/Work/KDE/md4qt/README.md} {Could you show an example of a plugin?}
                        \li \l {#I-didnt-understand-how-raw-text-data-correlates-with-a-paragraph//home/igor/Work/KDE/md4qt/README.md} {I didn't understand how raw text data correlates with a paragraph.}
                        \li \l {#How-can-I-get-a-string-of-MDStyleDelim//home/igor/Work/KDE/md4qt/README.md} {How can I get a string of \c {MD::StyleDelim}?}
                    \endlist


                \li \l {#Is-it-possible-to-find-Markdown-item-by-its-position//home/igor/Work/KDE/md4qt/README.md} {Is it possible to find \c {Markdown} item by its position?}
                \li \l {#How-can-I-walk-through-the-document-and-find-all-items-of-given-type//home/igor/Work/KDE/md4qt/README.md} {How can I walk through the document and find all items of given type?}
                \li \l {#How-can-I-add-and-process-a-custom-user-defined-item-in-MDDocument//home/igor/Work/KDE/md4qt/README.md} {How can I add and process a custom (user-defined) item in \c {MD::Document}?}
            \endlist


    \endlist

    \target #Example//home/igor/Work/KDE/md4qt/README.md
    \section1 Example

    \code /
    #define MD4QT_QT_SUPPORT
    #include <md4qt\1parser.hpp>
    
    int main()
    {
        MD::Parser<MD::QStringTrait> p;
    
        auto doc = p.parse(QStringLiteral("your_markdown.md"));
    
        for (auto it = doc->items().cbegin(), last = doc->items().cend(); it != last; ++it) {
            switch ((*it)->type())
            {
            case MD::ItemType::Anchor :
            {
                auto a = static_cast<MD::Anchor<MD::QStringTrait>*> (it->get());
                qDebug() << a->label();
            }
                break;
    
            default :
                break;
            }
        }
    
        return 0;
    }
    \endcode

    \target #Benchmark//home/igor/Work/KDE/md4qt/README.md
    \section1 Benchmark

    Approximate benchmark with \l {https://github.com/github/cmark-gfm} {cmark-gfm} says,
    that Qt6 version of \c {md4qt} is slower ~13 times.
    But you will get complete C++ tree structure of the Markdown document with all
    major extensions and sugar and cherry on the cake.


    \table

        \header

            \li Markdown library

            \li Result

        \row

            \li \l {https://github.com/github/cmark-gfm} {cmark-gfm}

            \li 0.22 ms

        \row

            \li \c {md4qt} with \c {Qt6}

            \li 2.9 ms

        \row

            \li \c {md4qt} with \c {Qt6} without \c {GitHub} auto-links extension

            \li 2.5 ms

    \endtable

    \target #Playground//home/igor/Work/KDE/md4qt/README.md
    \section1 Playground

    You can play in action with \c {md4qt} in \l {https://github.com/igormironchik/markdown-tools} {Markdown Tools}. There you can find \c {Markdown} editor/viewer/converter to \c {PDF}.

    And \l {https://invent.kde.org/office/klevernotes} {KleverNotes} from \c {KDE} uses \c {md4qt} too.

    \target #Release-notes//home/igor/Work/KDE/md4qt/README.md
    \section1 Release notes


    \list
        \li Note that version \b{4.0.0} is API incompatible with \b{3.0.0}. In version \b{4.0.0} were
            changed rules with spaces, this version fully supports CommonMark standard in this question.
            Methods \c {isSpaceBefore()}, \c {isSpaceAfter()} were removed, and spaces are presented as in
            Markdown, so keep it in mind.
    \endlist

    \target #Known-issues//home/igor/Work/KDE/md4qt/README.md
    \section1 Known issues

    You can find a list of know issues \l {md4qt-known_issues.md.html} {here}. These issues are controversial
    a little, so at this time they exists as is in \c {md4qt}. But if you'd like to see any of them
    resolved, welcome to discussion.

    \target #QA//home/igor/Work/KDE/md4qt/README.md
    \section1 Q/A

    \target #Why-another-AST-Markdown-parser//home/igor/Work/KDE/md4qt/README.md
    \section2 Why another AST Markdown parser?


    \list
        \li When I wrote this library I knew about \c {md4c} parser, but not about \c {cmark-gfm}.
            \c {md4c} was not suitable for my purposes, whereas \c {cmark-gfm} could do
            everything I needed. But God did it so, so I wrote \c {md4qt} and only later
            knew about \c {cmark-gfm}. Ok, code is written and tested. Let it be.

            What I can say yet, is that this library is C++. And for some people can be
            easier to use C++ code instead of C with freeing memory by hand. Qt do things
            easier by handling text encoding... So let it be, guys.

            And one more cherry on the cake - \c {md4qt} can parse Markdown recursively.
            What it is described below.


    \endlist

    \target #What-should-I-know-about-links-in-the-document//home/igor/Work/KDE/md4qt/README.md
    \section2 What should I know about links in the document?


    \list
        \li In some cases in Markdown link's URL is something document related. So, when
            you got a \c {MD::Link} in the document check if the labelled links of the
            document contains key with URL in the link, and if so, use URL from
            labelled links, look:

            \code /
            MD::Link<MD::QStringTrait> *item = ...;
            
            QString url = item->url();
            
            const auto it = doc->labeledLinks().find(url);
            
            if (it != doc->labeledLinks().cend()) {
                url = it->second->url();
            }
            \endcode


    \endlist

    \target #What-is-the-second-argument-of-MDParserparse//home/igor/Work/KDE/md4qt/README.md
    \section2 What is the second argument of \c {MD::Parser::parse()}?


    \list
        \li Second argument of \c {MD::Parser::parse()} is a flag that tells the
            parser to process Markdown files recursively or not. If parsing is recursive
            then if in the targeted Markdown file exist links to other Markdown files,
            then they will be parsed too and will exist in the resulting document.
    \endlist

    \target #What-is-an-MDAnchor//home/igor/Work/KDE/md4qt/README.md
    \section2 What is an \c {MD::Anchor}?


    \list
        \li As \c {md4qt} supports recursive Markdown parsing, then in the resulting
            document can be represented more than one Markdown file. Each file in the
            document starts with \c {MD::Anchor}, it just shows that during traversing through
            the document you reached new file.
    \endlist

    \target #Does-the-library-throw-exceptions//home/igor/Work/KDE/md4qt/README.md
    \section2 Does the library throw exceptions?


    \list
        \li No. This library doesn't use exceptions. Any text is a valid Markdown, so I
            don't need to inform user about errors. Qt itself doesn't use exceptions either.
            So you can catch only standard C++ exceptions, like \c {std::bad_alloc}, for
            example. Possibly with \c {MD::UnicodeStringTrait} you will catch more standard
            exceptions, possibly I missed something somewhere, but I tried to negotiate
            all possible exceptions.
    \endlist

    \target #Why-MDParser-and-MDDocument-are-templates//home/igor/Work/KDE/md4qt/README.md
    \section2 Why \c {MD::Parser} and \c {MD::Document} are templates?


    \list
        \li Since version \c {2.0.0} \c {md4qt} can be built not only with \c {Qt6}, but with
            \c {STL} too. The code of the parser is the same in both cases. I just added two
            ready traits to support different C++ worlds. With \c {STL} I use \c {ICU} library
            for Unicode handling, and \c {uriparser} library to parse and check URLs.
            These dependencies can be installed with the Conan package manager.
    \endlist

    \target #So-how-can-I-use-md4qt-with-Qt6-and-ICU//home/igor/Work/KDE/md4qt/README.md
    \section2 So, how can I use \c {md4qt} with \c {Qt6} and \c {ICU}?


    \list
        \li To build with \c {ICU} support you need to define \c {MD4QT_ICU_STL_SUPPORT}
            before including \c {parser.h}. In this case you will get access to
            \c {MD::UnicodeStringTrait}, that can be passed to \c {MD::Parser} as template
            parameter. You will receive in dependencies \c {C++ STL}, \c {ICU} and
            \c {uriparser}.

            To build with \c {Qt6} support you need to define \c {MD4QT_QT_SUPPORT}.
            In this case you will get access to \c {MD::QStringTrait} to work with
            Qt's classes and functions. In this case in dependencies you will
            receive \c {Qt6}.

            You can define both to have ability to use \c {md4qt} with \c {Qt6} and
            \c {ICU}.


    \endlist

    \target #ICU-is-slower-than-Qt6-Really//home/igor/Work/KDE/md4qt/README.md
    \section2 \c {ICU} is slower than \c {Qt6}? Really?


    \list
        \li Don't believe anybody, just build built-in \c {md_benchamrk} and have a
            look. Dry numbers say, that \c {Qt6} \c {QString} is ~2 times faster than
            \c {icu::UnicodeString} in such tasks. Markdown parsing implies to check
            every symbol, and tied to use access to every character in the string
            with \c {operator [] (...)}, or member \c {at(...)}. I do it very often in the
            parser's code and the profiler says that most of the run-time is spent
            on such operations. \c {QString} is just more optimized for accessing separate
            characters than \c {icu::UnicodeString}...
    \endlist

    \target #Why-is-parsing-wrong-on-Windows-with-stdifstream//home/igor/Work/KDE/md4qt/README.md
    \section2 Why is parsing wrong on Windows with \c {std::ifstream}?


    \list
        \li Such a problem can occur on Windows with MSVC if you open the file in text
            mode, so for \c {MD::Parser} always open \c {std::ifstream} with \c {std::ios::binary}
            flag. And yes, I expect to receive UTF-8 encoded content...
    \endlist

    \target #How-can-I-convert-MDDocument-into-HTML//home/igor/Work/KDE/md4qt/README.md
    \section2 How can I convert \c {MD::Document} into \c {HTML}?


    \list
        \li In version \c {2.0.5} were made commits with implementation of
            \c {MD::toHtml()} function. You can do the following:

            \code /
            #define MD4QT_QT_SUPPORT
            #include <md4qt\1traits.h>
            #include <md4qt\1parser.h>
            #include <md4qt\1html.h>
            
            int main()
            {
                MD::Parser<MD::QStringTrait> p;
            
                auto doc = p.parse(QStringLiteral("your_markdown.md"));
            
                const auto html = MD::toHtml(doc);
            
                return 0;
            }
            \endcode


    \endlist

    \target #How-can-I-obtain-positions-of-blockselements-in-Markdown-file//home/igor/Work/KDE/md4qt/README.md
    \section2 How can I obtain positions of blocks/elements in \c {Markdown} file?


    \list
        \li Done in version \c {2.0.5}. Remember that all positions in \c {md4qt} start with 0,
            where first symbol on first line will have coordinates \c {(0,0)}. One more important thing is
            that all ranges of position in \c {md4qt} are given inclusive, that mean that last column
            of any element will point to the last symbol in this element.
    \endlist

    \target #How-can-I-easily-traverse-through-the-MDDocument//home/igor/Work/KDE/md4qt/README.md
    \section2 How can I easily traverse through the \c {MD::Document}?


    \list
        \li Since version \c {2.6.0} in \c {visitor.h} header implemented \c {MD::Visitor} interface
            with which you can easily walk through the document, all you need is implement/override
            virtual methods to handle that or another element in the document, like:

            \code /
            virtual void onHeading(
                \1\1! Heading.
                MD::Heading<Trait> *h) = 0;
            \endcode


    \endlist

    \target #Why-dont-you-have-an-implementation-for-pure-STL-with-stdstring//home/igor/Work/KDE/md4qt/README.md
    \section2 Why don't you have an implementation for pure \c {STL} with \c {std::string}?


    \list
        \li Because of performance, I did a pure \c {STL} implementation where the string class
            was an \c {std::string} with some small third-party library to handle \c {UTF8}, and
            benchmark said that the performance was like with \c {Qt6} \c {QString}, so I decided
            to not support third trait. Maybe because I am lazy?
    \endlist

    \target #Is-it-possible-to-write-custom-text-plugin-for-this-parser//home/igor/Work/KDE/md4qt/README.md
    \section2 Is it possible to write custom text plugin for this parser?


    \list
        \li Since version \c {3.0.0} in the \c {MD::Parser} was added a method for adding custom
            text plugins.

            \code /
            \1\1! Add text plugin.
            void addTextPlugin(
                \1\1! ID of a plugin. Use TextPlugin::UserDefinedPluginID value for start ID.
                int id,
                \1\1! Function of a plugin, that will be invoked to processs raw text.
                MD::TextPluginFunc<Trait> plugin,
                \1\1! Should this plugin be used in parsing of internals of links?
                bool processInLinks,
                \1\1! User data that will be passed to plugin function.
                const typename Trait::StringList &userData);
            \endcode


    \endlist

    \target #What-is-a-ID-of-a-plugin//home/igor/Work/KDE/md4qt/README.md
    \section3 What is a \c {ID} of a plugin?


    \list
        \li \c {ID} of a plugin is a regular \c {int} that should be (but not mandatory) started from

            \code /
            enum TextPlugin : int {
                UnknownPluginID = 0,
                GitHubAutoLinkPluginID = 1,
                UserDefinedPluginID = 255
            }; \1\1 enum TextPlugin
            \endcode

            \c {MD::UserDefinedPluginID} value. Note that plugins will be invoked corresponding
            to its \c {ID} from smallest to largest, so a developer can handle an order of text
            plugins.


    \endlist

    \target #What-is-a-MDTextPluginFuncTrait//home/igor/Work/KDE/md4qt/README.md
    \section3 What is a \c {MD::TextPluginFunc<Trait>}?


    \list
        \li Text plugin is a usual function with a signature

            \code /
            template<class Trait>
            using TextPluginFunc = std::function<void(std::shared_ptr<Paragraph<Trait>>,
                TextParsingOpts<Trait> &, const typename Trait::StringList &)>;
            \endcode

            You will get already parsed \c {MD::Paragraph} with all items in it. And you are
            able to process remaining raw text data and check it for what you need.

            \c {MD::TextParsingOpts} is an auxiliary structure with some data. You are interested
            in \c {bool collectRefLinks;}, when this flag is \c {true} the parser is in a state of
            collecting reference links, and on this stage plugin may do nothing.

            A last argument of plugin function is a user data, that was passed to
            \c {MD::Parser::addTextPlugin()} method.

            A most important thing in \c {MD::TextParsingOpts} structure is a
            \c {std::vector<TextData> m_rawTextData;}. This vector contains not processed raw
            text data from \c {Markdown}. The size of \c {m_rawTextData} is the same as a count of
            \c {MD::Text} items in \c {MD::Paragraph}, and theirs sizes should remain equal. So, if you replace
            one of text item with something, for example link, corresponding text item
            should be removed from \c {MD::Paragraph} and \c {m_rawTextData}. Or if you replace just
            a part of text item - it should be modified in \c {MD::Paragraph} and \c {m_rawTextData}.
            Be careful, it's UB, if you will make a mistake here, possibly you will crash.

            One more thing - don't forget to set positions of elements in \c {MD::Document} to new
            values if you change something, and don't forget about such things like
            \c {MD::ItemWithOpts::openStyles()} and \c {MD::ItemWithOpts::closeStyles()}. Document should
            remain correct after your manipulations, so any syntax highlighter, for example,
            won't do a mistake.

            Note, that \c {MD::TextData} is

            \code /
            struct TextData {
                typename Trait::String m_str;
                long long int m_pos = -1;
                long long int m_line = -1;
            };
            \endcode

            And \c {m_pos} and \c {m_line} here is relative to \c {MD::MdBlock<Trait> & fr;} member of
            \c {MD::TextParsingOpts}, but document require absolute positions in the \c {Markdown}
            text. So when you will set positions to new items, use, for example, a following
            code.

            \code /
            setEndColumn(po.fr.data.at(s.line).first.virginPos(s.pos));
            \endcode

            where \c {s} is an object of \c {MD::TextData} type.


    \endlist

    \target #What-is-processInLinks-flag-for//home/igor/Work/KDE/md4qt/README.md
    \section3 What is \c {processInLinks} flag for?


    \list
        \li \c {processInLinks} flag should be set to false if you desire to not process your
            plugin in link's captions, as, for example, links can't contain other links, so
            if you are implementing a plugin for new links this flag should be set to \c {false}
            for your plugin.
    \endlist

    \target #What-for-is-a-userData-argument//home/igor/Work/KDE/md4qt/README.md
    \section3 What for is a \c {userData} argument?


    \list
        \li This list of strings will be passed to plugin function. This is auxiliary data
            that can be handy for plugin implementation.
    \endlist

    \target #Could-you-show-an-example-of-a-plugin//home/igor/Work/KDE/md4qt/README.md
    \section3 Could you show an example of a plugin?


    \list
        \li In \c {md4qt} already exists one text plugin for handling GitHub's auto-link. A
            plugin function is quite simple, look.

            \code /
            template<class Trait>
            inline void
            githubAutolinkPlugin(std::shared_ptr<Paragraph<Trait>> p,
              TextParsingOpts< Trait > &po)
            {
                if (!po.collectRefLinks) {
                    long long int i = 0;
            
                    while (i >= 0 && i < (long long int) po.rawTextData.size()) {
                        i = processGitHubAutolinkExtension(p, po, i);
            
                        ++i;
                    }
                }
            }
            \endcode

            But \c {MD::processGitHubAutolinkExtension()} is not so trivial :) Have a look
            at its implementation to have a good example, it's placed in \c {parser.h}.

            Good luck with plugining. :)


    \endlist

    \target #I-didnt-understand-how-raw-text-data-correlates-with-a-paragraph//home/igor/Work/KDE/md4qt/README.md
    \section3 I didn't understand how raw text data correlates with a paragraph.


    \list
        \li Let I will show you on example how raw text data correlate with paragraph. Just two
            diagrams and you won't have any more questions. Look.

            Consider we want to replace any occurrence of \c {@X} by some kind of a link. Before
            modifications we had.

            \image ./docs/pics/paragraph_before.svg

            And after work of your plugin we should have.

            \image ./docs/pics/paragraph_after.svg


    \endlist

    \target #How-can-I-get-a-string-of-MDStyleDelim//home/igor/Work/KDE/md4qt/README.md
    \section3 How can I get a string of \c {MD::StyleDelim}?


    \list
        \li Since version \c {3.0.0} was added a function to get a substring from text fragment with given
            virgin positions.

            \code /
            template<class Trait>
            inline typename Trait::String
            virginSubstr(const MdBlock<Trait> &fr, const WithPosition &virginPos);
            \endcode

            And a function to get local position from virgin one.

            \code /
            template<class Trait>
            inline std::pair<long long int, long long int>
            localPosFromVirgin(const MdBlock<Trait> &fr,
                long long int virginColumn,
                long long int virginLine)
            \endcode


    \endlist

    \target #Is-it-possible-to-find-Markdown-item-by-its-position//home/igor/Work/KDE/md4qt/README.md
    \section2 Is it possible to find \c {Markdown} item by its position?


    \list
        \li Since version \c {3.0.0} was added new structure \c {MD::PosCache}. You can pass
            \c {MD::Document} into its \c {MD::PosCache::initialize()} method and find first item with all its
            nested first children by given position with \c {MD::PosCache::findFirstInCache()} method.
    \endlist

    \target #How-can-I-walk-through-the-document-and-find-all-items-of-given-type//home/igor/Work/KDE/md4qt/README.md
    \section2 How can I walk through the document and find all items of given type?


    \list
        \li Since version \c {3.0.0} was added algorithm \c {MD::forEach()}.

            \code /
            \1\1! Calls function for each item in the document with the given type.
            template<class Trait>
            inline void
            forEach(
                \1\1! Vector of item's types to be processed.
                const typename Trait::template Vector<ItemType> &types,
                \1\1! Document.
                std::shared_ptr<Document<Trait>> doc,
                \1\1! Functor object.
                ItemFunctor<Trait> func,
                \1\1! Maximun nesting level.
                \1\1! 0 means infinity, 1 - only top level items...
                unsigned int maxNestingLevel = 0);
            \endcode


    \endlist

    \target #How-can-I-add-and-process-a-custom-user-defined-item-in-MDDocument//home/igor/Work/KDE/md4qt/README.md
    \section2 How can I add and process a custom (user-defined) item in \c {MD::Document}?


    \list
        \li Since version \c {3.0.0} in \c {MD::ItemType} enum appeared \c {MD::UserDefined} enumerator.
            So you can inherit from any \c {MD::Item} class and return from \c {type()} method
            value greater or equal \c {MD::ItemType::UserData}. To handle user-defined types of
            items in \c {MD::Visitor} class now exists method \c {void onUserDefined(MD::Item<Trait> *item)}.
            So you can handle your custom items and do what you need.
    \endlist


*/
